%\section*{EOPL\cite{friedman2001eopl} Foreword by Hal Abelson}
\section*{EOPL Foreword by Hal Abelson}
%\addcontentsline{toc}{section}{EOPL Foreword by Hal Abelson}
\transource{Essentials of Programming Language}
\trancontent
这本书让你亲身感受计算机语言中最基本的一个思想：

\begin{quotation}
计算机语言的解释器就是另一个程序。
\end{quotation}

这听起来显而易见，不是么？但是他的内涵确是深远的。如果你是一位计算机理论家，解释器的思想会让你想起哥德尔发现的形式逻辑系统的限制，图灵的统一计算理论，和冯诺依曼机思想。如果你是一个程序员，对解释器的掌握将是你力量的源泉。他带来思想上的一次升华，一种对编程的认识上的改变。

我在学习解释器之前，已经有大量的编程实践，写出过一些大型程序。比如有一个用PL/I写的大型数据记录与索引系统。当我写完这个系统时，我意识到我将PL/I看作是一群不知道在哪的语言设计师编写的一套固定规则。我的工作不是去修改这些规则，甚至是深度理解他们，而是拿起一本厚厚的手册，挑选要用的这个或那个特性。我从来没有思考语言组织的底层结构或是改变语言设计者的一些决定。我不知道怎么通过创建一个嵌入的子语言来方便组织我的实现。所以整个程序对我来说就是一个巨大又复杂的马赛克块，这一块东西中的每一个部件都需要仔细打磨来让他们能够合适地放置其中。而不是将其看作是几个语言的集合，这样每一个部件都可以灵活组合。如果你不了解解释器，你还是可以编程，甚至成为一个出色的程序员，但是你不会是一个大师。

这里有三个作为程序员的你应该学习解释器的理由。

首先，有时你需要实现一个解释器，也许不是一个完整的通用编程语言的解释器，但是还是一个解释器。基本上所有需要灵活的人机交互的复杂计算机系统 --- 比方说计算机绘图系统，信息检索系统 --- 包含一定程度上的解释器来组织交互。这些程序可能包含一些复杂的独立操作 --- 在屏幕上的一块区域绘制背景，对数据库进行查询操作 --- 而解释器是将这些独立操作组合成一些有用的模式的胶水。你能把一个操作的结果作为另一个操作的输入么？你能给一系列的操作组合命名么？这个名字是本地的还是全局的呢？你能参数化一套操作组合并给这些输入命名么？等等。无论这些独立操作如何的复杂和完善，决定一个系统能力的通常直接是这种``胶水''的质量。很容易找到这种独立操作不错但是组织极差的程序的例子；回过头来看，我知道我的PL/I数据库系统的``胶水''肯定是非常失败的。

其次，即使是那些本身不是解释器的程序也包含重要的类似解释器的组件。在那些复杂的计算机辅助设计系统中，你有可能会见到一些几何形状识别语言，图形解释器，基于规则的控制解释器，面向对象语言解释器一起工作。一种强大的组织复杂系统的方式是将其设计为一些语言的集合，每一种语言都提供一种不同的角度，与程序基本元素工作的不同方式。为正确的目的选择一种合适种类的语言并理解实现中的妥协：这就是解释器研究的内容。

第三个学习解释器的原因是显式包含语言结构的编程技巧变得越来越重要了。当前大家对面向对象系统中类的层次结构的设计与操作的关注就是这种趋势的一个例子。也许这就是我们的程序变得越来越复杂造成的不可变结果 --- 更加显式的关注语言本身或许是在我们处理复杂性时最好的工具。再次思考最基本的思想：解释器本身就是一个程序。但是我们的程序是用一个语言编写的，这个语言的解释器又是一个用某一个语言编写的，这个语言的解释器又是……。也许将程序和编程语言区别对待就是一个误导性的思想，以后的程序员不会认为自己是在写一个特定的程序，而是为每一个新的应用都创建新的语言。

Friedman和Wand做出了里程碑式的工作，他们的书籍将改变编程语言课程的现状。他们不仅告诉你解释器相关的东西，他们还向你展示他。这本书的核心是一系列解释器的旅程，从一个抽象的高阶语言开始，一步步将语言特性显式表示知道一个完整的机器。事实上你可以运行这些代码，研究并修改他们，改变这些解释器处理作用域，传参，控制结构的方式，等等。

在使用解释器研究编程语言的执行过程之后，作者展示了同样的思想如何运用于分析程序而不实际执行他们。在两个新的章节中，他们讲解了如何实现类型检查器和类型推到，以及这些特性如何在现代的面向对象语言中交互。

这种方式之所以迷人的一部分原因在于作者们选择了一个好的工具 --- Scheme编程语言。这门语言结合了Lisp统一的语法与数据抽象能力和Algol的词法作用域与块状结构。而且强大的工具在大师的手中才会最为强大。这本书中的几个示例解释器是非常出色的模型。事实上，因为他们是可运行的模型，我确信今后这些解释器和分析器将会成为许多编程系统的的核心部分。

这不是一本容易阅读的书。掌握解释器不是一件容易的事，却是处于好的理由的。语言设计者相比较于普通的应用程序员来说是不属于最终使用者这一层的更高一个级别的人。在设计应用程序的时候，你将会思考具体需要执行的任务，考虑需要包含哪些特性。但是在设计语言的时候，你会考虑人们可能会去实现的各种各样的应用程序，以及他们将会如何去实现这些程序。你的语言是采用静态作用域还是动态作用域，或者是混合的？需不需要继承？按引用传参还是按值传参？continuations是显式的还是隐含的？这些都取决于你希望你的语言如何被使用，哪些类型的程序应该方便编写，哪些程序变得难写是可以承受的。

而且，解释器真的是精致的程序。简单的改变一行都会为最终语言的行为带来巨大的不同。不要认为这些程序可以略读 --- 这世上很少有人能够浏览一遍新的解释器就能够预测他在甚至是很简单的一个程序上的行为。所以研究这些程序吧。更好的是，运行他们 --- 他们是可以工作的代码。尝试解释执行一些简单的表达式，然后再试些复杂的。添加一些错误消息，修改这些解释器，设计自己的变体。尝试真的掌握这些程序，而不仅仅是对他们如何运行有一个模糊的感觉。

如果你这么做了，你对编程的看法会改变的，以及你如何看待自己程序员的身份。你会认为自己是语言的设计者而不仅仅是语言的用户，一个选择语言由哪些规则组合在一起的人，而不仅仅是一个只能遵从其他人定下的规则的人。

\subsection*{第三版后记}

上面的前言仅仅是七年前写的。之后，信息应用和服务进入了全世界人们的日常生活中，这在1990年是无法想象的。这借助于持续增长的编程语言和编程框架的生态 --- 都是建立在持续完善的解释器平台上。

想要创建网页？在1990年，这意味着排版静态文字和图片，事实上是创建一个被浏览器运行的只需要执行一条``\texttt{print}''语句的程序。而现在的动态网页使用了Javascript这类脚本语言（解释其语言的另一个名字）。浏览器程序可以很复杂，包含对Web服务器的异步调用，而Web服务器通常运行着一个完全不一样的编程框架，可能伴随运行着许多服务，每一个又有自己的语言。

或者在像魔兽世界这种大型多人在线游戏中创建机器人来优化你的NPC的表现。在这种情况下，你可能在使用像Lua这种脚本语言，可能为了方便表达多种类别的行为而带上面向对象的扩展。

或者你正在为大型计算集群编程来提供全球级别的索引和搜索功能。如果是这样，你可能会使用函数式编程语言的map-reduce范式来从显式管理每一个处理器的调度这些细节中解脱出来。

或者你可能在为传感器网络编写新的算法，所以在探索如何使用惰性求值来更好的处理并行和数据聚合。或者在探索如何用如XSLT这类变换系统来控制网页。或者在设计多媒体流的转换与混合框架。或者……

这么多新的应用！这么多新的语言！这么多新的解释器！

一如以往，新手程序员，甚至是熟练工，可以单独掌握每一个新的框架，在他们的固定规则下工作。但是创建新的框架需要大师级别的能力：理解跨越各个语言而不变的原则，懂得哪些语言特性适合于哪些类型的应用，并且知道如何制作出将这种语言实际运行起来的解释器。这些将是你们能从这本书中学到的技巧。

{
\setlength{\parindent}{0pt}
\vspace{30pt}
Hal Abelson\\
马萨诸塞州，剑桥\\
2007年九月
}

