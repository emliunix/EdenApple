%
% 第4章 parser
% 这个章节讲monad和parsec
% 毕竟monad也算是程序运行的一种抽象，还是有必要讲一讲的，
% 顺便把上次写的monad和parser的一点感想直接丢过来。
% 凑凑字数 <- 真实目的
%

\chapter{Monadic Parser Combinator}

讲到Parser，这两天除了实现了一个基本的VM，剩下的时间基本上在鼓捣Parser。看了些许Parser Combinator的资料，重点在parsec上。parsec是一个Monadic Parser Combinator，在阅读过程中，略微有两点想法。
一个是对Monad的理解，Monad是一个代数结构，Monad的数据首先是一个函数（具备 * -> * 这样的kind），其次，对他有bind(>>=)，>>，return，fail这几个操作。这几个操作的特点大概是都是以Monad数据为输入，返回的还是对应Monad的数据。
所以，如果把parser看作是一个接受String，返回结果和剩余String (:: (a, String))的函数，重点是把他看作函数，那么Parser Combinator就是对这些函数进行不断的组合。
Monad的组合操作都有个特点，就是结构上面体现了一种顺序结构。比如说bind操作，他的类型是 `m a -> (a -> m b) -> m b`。可以这么理解这个类型，首先进行`m a`操作，该操作的结果是`a`类型。再看第二个传入的值，他是一个函数，这个函数接受第一个操作的结果，并根据这个结果生成出第二个操作(类型为`m b`)，第二个操作返回`b`类型的结果。那么这个先进行第一个操作，再进行第二个操作，并最终返回第二个操作的结果的着整个一个过程，也就是两个过程按顺序执行的组合过程，就是bind操作所生成的值。
第二个是关于Parser本身的，Parser有两个基本的组合，一个是上面的bind(`>>=`)组合，还一个choice(`<|>`)组合。在观察组合之前先观察parser本身，parser本身的类型 `String -> (a, String)`，反映了parser本身的功能，比较有意思的是返回的数据中还包括了未处理的文本数据。这样子可以在下一个parser传入这个文本，完成下一步的parse。正是这种结构，使得parser的组合变得简单直接。事实上，parser的bind操作就是这么一种操作：将第一个parse返回的未处理文本传入第二个parse。
由此来看，bind操作是顺序组合，与此相对应的，`<|>`操作是一种平行组合。`<|>`操作将两个操作组合，首先将文本传入第一个操作，如果第一个操作失败，转而将相同的文本传入第二个操作。
BNF文法中通常将一个元素表示为几个元素的顺序组合或者是用或`|`来表示两种不同的组合都是这个元素。比如：
```
<sexp> ::= <pair> | <atom>
<pair> ::= (<sexp> . <sexp>)
```
而这正好就是parsec中的两种基本组合。
monadic只是一种style，在parsec的论文中也讨论了另一种sytle，但是没仔细看，也不清楚是怎么实现组合的。关于parse，其实还有老多的东西不清楚，比如怎么稳妥的实现lookahead，怎么左递归，有哪些best practice什么的。
还有个就是在parse sexp的时候，感觉blank字符的处理还是比较麻烦，这种字符起到分割作用但又不是必须的，两个token之间不一定需要空白字符来分割。有一种想法是先lex一遍将字符串变成token串，然后在以parser转换成树状结构，再然后来一遍pass将这个树转换成Expr树，Expr树中会带上具体的语义，比如这是一棵Let树，那是一棵If树，还有Lambda树之类的。到这种状态，基本上对于compile而言就是万事俱备，只差临门一脚了。
